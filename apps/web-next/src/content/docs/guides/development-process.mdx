---
title: "Development Process"
description: "Branch strategy, PR workflow, plugin team independence, and contribution guidelines for the NaaP platform."
order: 0
---

## Overview

NaaP is a monorepo that powers the Livepeer Network-as-a-Platform. It is maintained by **core contributors** who own the shell, shared packages, and infrastructure, and by **plugin teams** who independently build and ship features within their plugin directories.

This guide covers everything you need to know to contribute effectively — whether you are a new plugin team, a core contributor, or a first-time open source contributor.

---

## Repository Layout

```
livepeer/naap                     ← upstream (public)
├── apps/web-next/                ← Next.js shell (core team)
├── packages/                     ← shared SDK, types, utils (core team)
├── services/                     ← core backend services (core team)
├── plugins/
│   ├── gateway-manager/          ← plugin team A owns this
│   ├── community/                ← plugin team B owns this
│   ├── daydream-video/           ← plugin team C owns this
│   └── ...                       ← each team owns their directory
├── .github/workflows/            ← CI/CD (core team)
├── bin/                          ← platform scripts (core team)
└── docker/                       ← infrastructure (core team)
```

**Key principle:** Plugin teams own their `plugins/<name>/` directory. Core contributors own everything else. Ownership is enforced via CODEOWNERS.

---

## Branch Strategy

NaaP uses a **feature-branch-off-main** (trunk-based) model. All PRs target `main` directly. Vercel PR previews serve as staging for every PR.

```
  feature branches                     main (production)
  ─────────────────                    ─────────────────

  feat/video/webrtc ─── PR ──────────►│                │
                        (preview URL)  │  auto-deploy   │
  fix/social/auth ───── PR ──────────►│  to production  │
                        (preview URL)  │  on merge       │
  feat/infra/cache ──── PR ──────────►│                │
                        (preview URL)  │                │
```

| Branch | Purpose | Deploys To | Who Merges |
|--------|---------|------------|------------|
| `main` | Production. Single source of truth. | Production (auto) | Plugin teams + core (via merge queue) |
| `feat/<team>/<desc>` | New features | PR preview (auto) | Author opens PR |
| `fix/<team>/<desc>` | Bug fixes | PR preview (auto) | Author opens PR |
| `chore/<desc>` | Docs, CI, tooling | PR preview (auto) | Author opens PR |

### Branch naming conventions

```bash
# Plugin team features
feat/video/webrtc-input        # team: video, feature: webrtc-input
feat/social/threaded-replies   # team: social, feature: threaded-replies

# Plugin team fixes
fix/wallet/staking-overflow    # team: wallet, fix: staking-overflow

# Core contributor work
feat/infra/redis-rate-limit
fix/shell/plugin-loader-race
chore/ci/add-e2e-matrix
docs/sdk/hook-migration-guide
```

---

## PR Process — Step by Step

### 1. Create your branch

```bash
# Fork the repo (first time only)
# Clone your fork
git clone https://github.com/<you>/NaaP.git
cd NaaP
git remote add upstream https://github.com/livepeer/naap.git

# Always branch from latest main
git fetch upstream
git checkout -b feat/my-team/my-feature upstream/main
```

### 2. Make your changes

- Start developing: `./bin/start.sh --fast` (or `./bin/start.sh my-plugin`)
- Make focused, incremental changes
- Write tests for new functionality
- Follow [Conventional Commits](#commit-conventions) for all commit messages

### 3. Open a PR against `main`

```bash
git push origin feat/my-team/my-feature
# Then open a PR on GitHub: base = main, compare = your branch
```

### 4. Automated checks run

Once your PR is open, the following happens automatically:

| Step | What happens | Who is responsible |
|------|--------------|--------------------|
| **Labeler** | Auto-labels PR based on changed file paths | Bot |
| **CODEOWNERS** | Assigns reviewers — your team for plugin code, core team for shared code | Bot |
| **CI** | Runs path-filtered tests — only affected packages are tested | Bot |
| **Copilot** | AI code review with project-specific context | Bot |
| **CodeRabbit** | AI code review with request-changes workflow | Bot |
| **Commit lint** | Validates commit messages follow Conventional Commits | Bot |
| **PR size** | Warns if PR exceeds 400 changed lines | Bot |
| **Conflict check** | Alerts if PR conflicts with base branch | Bot |
| **Vercel preview** | Deploys a preview URL for testing | Bot |

### 5. Review and iterate

- Plugin-only PRs: your team reviews and approves
- Cross-cutting PRs: core team is auto-assigned and must also approve
- All review conversations must be resolved before merge

### 6. Merge

Once approved and CI passes, the PR enters the **merge queue** and merges automatically. Changes are **auto-deployed to production** with health checks.

### 7. Release tagging (on-demand)

A core maintainer can trigger the **"Tag Release"** workflow to create a versioned release:

1. Run the "Tag Release" workflow from GitHub Actions
2. Specify a version (e.g., `v1.2.0`)
3. A Git tag and GitHub Release are created with auto-generated notes

---

## For Plugin Teams

### You own your directory

Your team has full autonomy over `plugins/<your-plugin>/`. This includes:

- **Frontend** (`plugins/<name>/frontend/`) — React components, styles, state
- **Backend** (`plugins/<name>/backend/`) — Express API, business logic
- **Config** (`plugins/<name>/plugin.json`) — manifest, routes, permissions

You decide code style, review standards, and internal conventions within your directory.

### What you CAN do (freely)

- Ship features, fixes, and refactors within your plugin directory
- Review and approve your own team's PRs (no core team needed)
- Add dependencies to your plugin's `package.json`
- Create your own database tables in your plugin's schema
- Choose your own state management, UI patterns, and testing strategy
- Deploy to production by merging to `main`

### Plugin team boundaries

- **Do NOT import from other plugins.** Use the event bus (`@naap/plugin-sdk`) for cross-plugin communication
- **Do NOT modify shared packages** (`packages/*`) without core team review
- **Do NOT modify the shell** (`apps/web-next/`) without core team review
- **Do NOT hardcode your plugin in the shell.** Everything is driven by `plugin.json` manifests
- **Do NOT modify CI workflows** (`.github/workflows/`) without core team review
- **Do NOT commit secrets** (`.env` files, API keys) — these are gitignored

### Setting up your plugin development

```bash
# 1. Fork and clone
git clone https://github.com/<you>/NaaP.git
cd NaaP
git remote add upstream https://github.com/livepeer/naap.git

# 2. First-time setup (run once after clone)
./bin/setup.sh --start

# 3. Daily development (after first setup):
./bin/start.sh --fast                # smart start (~6s): auto-detects your changes
./bin/start.sh <your-plugin-name>    # shell + your plugin (~6s)
./bin/start.sh dev <your-plugin-name>  # with frontend HMR
./bin/start.sh stop                  # parallel stop (~2s)

# 4. Login at http://localhost:3000
#    Email: admin@livepeer.org  Password: livepeer
```

### Plugin directory structure

```
plugins/your-plugin/
├── plugin.json               ← manifest (routes, permissions, config)
├── frontend/
│   ├── package.json
│   ├── src/
│   │   ├── App.tsx           ← main component (loaded by shell)
│   │   ├── components/       ← your UI components
│   │   └── hooks/            ← your custom hooks
│   └── vite.config.ts        ← build config (UMD bundle)
├── backend/
│   ├── package.json
│   ├── src/
│   │   ├── server.ts         ← Express server
│   │   ├── routes/           ← API routes
│   │   └── services/         ← business logic
│   └── .env                  ← local config (gitignored)
└── README.md
```

### Your plugin.json is your contract

The `plugin.json` manifest tells the shell everything it needs to know:

```json
{
  "name": "myPlugin",
  "displayName": "My Plugin",
  "version": "1.0.0",
  "frontend": {
    "entry": "dist/production/my-plugin.js",
    "devPort": 5180,
    "routes": ["/my-route", "/my-route/*"],
    "navigation": {
      "label": "My Plugin",
      "icon": "Star",
      "order": 10
    }
  },
  "backend": {
    "entry": "dist/server.js",
    "devPort": 4020,
    "healthCheck": "/healthz",
    "apiPrefix": "/api/v1/my-plugin"
  },
  "permissions": {
    "shell": ["navigation", "theme", "notifications"]
  }
}
```

### Daily workflow for plugin teams

```bash
# Start your day — sync with upstream
git fetch upstream
git rebase upstream/main

# Work on a feature
git checkout -b feat/my-team/cool-feature

# Start developing (~6s)
./bin/start.sh --fast              # auto-detects your changed plugins
# or explicitly:
./bin/start.sh my-plugin           # shell + your plugin backend

# Make changes...

# Quick restart after changes (~8s total)
./bin/start.sh stop && ./bin/start.sh --fast

# Commit using conventional commits
git commit -m "feat(plugin/my-plugin): add cool feature"

# Push and open PR against main
git push origin feat/my-team/cool-feature
```

---

## For Core Contributors

Core contributors maintain the platform that all plugin teams build on. Your work directly affects every team's productivity.

### What you own

- **Shell** (`apps/web-next/`) — the Next.js host that loads plugins
- **Shared packages** (`packages/*`) — SDK, types, utils, theme, UI components
- **Core services** (`services/*`) — base-svc, plugin-server, infrastructure
- **Infrastructure** (`bin/`, `docker/`, `.github/`) — scripts, CI/CD, Docker

### What you should do

- **Review cross-cutting PRs promptly.** Plugin teams are blocked until you review changes that touch shared code. Aim for < 24h review SLA
- **Keep the SDK stable.** Breaking changes require an RFC, migration guide, and version bump
- **Maintain CI health.** Fix flaky tests immediately — they erode trust
- **Tag releases as needed.** Use the "Tag Release" workflow to create versioned releases
- **Document changes.** SDK changes need updated docs before merge

### Core team boundaries

- **Do NOT merge plugin-only PRs.** Let plugin teams self-govern their code
- **Do NOT make breaking SDK changes without an RFC.** Plugin teams depend on stable APIs
- **Do NOT bypass CI.** Even urgent fixes must pass automated checks
- **Do NOT block plugin teams unnecessarily.** If a cross-cutting change is low-risk, review and approve quickly
- **Do NOT force-push to `main`.** It is a protected branch

### Handling cross-cutting changes

When a plugin team needs a change in shared code:

1. Plugin team opens an issue describing the need
2. Core team evaluates and either:
   - Makes the change themselves, or
   - Guides the plugin team to submit a PR with core team as reviewer
3. The PR requires both plugin team approval AND core team approval
4. CI runs the SDK compatibility matrix to ensure no regressions

---

## Deployment-Safe Development

NaaP deploys to **Vercel** (production). Plugins are built as UMD bundles and served from the same origin. Understanding the deployment model prevents the most common breakages.

### How It Works on Vercel

```
Local Dev                          Vercel Production
─────────                          ──────────────────
Shell:     localhost:3000           naap.vercel.app (Next.js)
Plugin UI: loaded via CDN bundle   loaded via /cdn/plugins/...
Plugin API: localhost:4006          /api/v1/community (same-origin proxy)
Database:  localhost:5432           Neon PostgreSQL (via DATABASE_URL)
```

On Vercel, there are **no separate backend processes** — all API calls go through the Next.js API proxy at the same origin. Plugin frontends must use deployment-aware URL resolution.

### Rules for Plugin Developers

**Always do:**
- Use `getPluginBackendUrl()` from `@naap/plugin-sdk` for all API URLs
- Use `usePluginApi()` hook for API calls in React components
- Use `createPluginConfig()` from `@naap/plugin-build/vite` for your Vite config
- Keep your `tailwind.config.js` (per-plugin theme/content paths)
- Test your plugin loads correctly at `/plugins/<your-plugin>` after building

**Never do:**
- Hardcode `localhost:PORT` in frontend code (breaks on Vercel)
- Hardcode `window.location.hostname + ':' + port` (appends dev port to production domain)
- Add a `postcss.config.js` to your plugin (breaks Vercel builds — PostCSS is in the shared Vite config)
- Use `*/` inside JSDoc comments (e.g., `plugins/*/plugin.json` — the `*/` closes the comment and breaks esbuild)
- Use `((count++))` in bash scripts with `set -e` (when count=0, returns exit code 1)

### API URL Quick Reference

```typescript
// In React components (recommended):
import { usePluginApi } from '@naap/plugin-sdk';
const api = usePluginApi();
const data = await api.get('/api/v1/my-plugin/items');

// In non-React code:
import { getPluginBackendUrl } from '@naap/plugin-sdk';
const BASE = getPluginBackendUrl('my-plugin', { apiPath: '/api/v1/my-plugin' });
// Local → http://localhost:4020/api/v1/my-plugin
// Vercel → /api/v1/my-plugin

// WRONG — will break on Vercel:
const BASE = 'http://localhost:4020/api/v1/my-plugin';
```

---

## Commit Conventions

Use [Conventional Commits](https://www.conventionalcommits.org/). This is enforced by CI.

```
<type>(<scope>): <short description>
```

### Types

| Type | When to use |
|------|-------------|
| `feat` | New feature or capability |
| `fix` | Bug fix |
| `refactor` | Code restructuring, no behavior change |
| `docs` | Documentation only |
| `test` | Adding or updating tests |
| `chore` | Tooling, CI, dependencies |
| `perf` | Performance improvement |

### Scopes

| Scope | Example |
|-------|---------|
| `shell` | `feat(shell): add plugin error boundary` |
| `sdk` | `feat(sdk): add usePluginConfig hook` |
| `plugin/<name>` | `fix(plugin/community): handle empty post list` |
| `base-svc` | `refactor(base-svc): extract auth routes` |
| `infra` | `chore(infra): upgrade postgres to 16` |
| `ci` | `chore(ci): add e2e test matrix` |
| `docs` | `docs(sdk): update hook reference` |

---

## Hotfix Process

Since all PRs target `main`, the hotfix process is the same as normal development:

```bash
# 1. Branch from main
git checkout -b fix/hotfix-description upstream/main

# 2. Make the minimal fix
# 3. Open a PR against main
# 4. Core maintainer reviews and approves
# 5. Merge — production deploys automatically
```

Hotfixes go through the same PR and CI process as any other change. The merge queue ensures `main` stays green.

---

## Testing Requirements

| Change type | Required tests |
|-------------|---------------|
| SDK / shared packages | Unit tests. Coverage must not decrease |
| Plugin backend | Health check + basic endpoint tests |
| Plugin frontend | Component tests for critical flows |
| Shell changes | Manual smoke test with 2+ plugins loaded |
| Breaking changes | Migration notes in PR description |

Run tests before pushing:

```bash
# Run all tests
npm test

# Run tests for a specific plugin
cd plugins/my-plugin/frontend && npm test
cd plugins/my-plugin/backend && npm test

# Typecheck
npm run typecheck
```

---

## Environment and Tools

| Tool | Version | Purpose |
|------|---------|---------|
| Node.js | 20+ | Runtime |
| npm | 10+ | Package manager (workspaces) |
| Docker | Latest | PostgreSQL database |
| TypeScript | ~5.8 | Type safety |
| React | 19 | UI framework |
| Next.js | 15.5 | Shell framework |
| Vite | 6 | Plugin builds |
| Nx | 22 | Monorepo task runner |

---

## Quick Reference

### Everyday commands (plugin teams)

```bash
./bin/start.sh --fast            # Smart start (~6s): auto-detects changed plugins
./bin/start.sh my-plugin         # Shell + one plugin backend (~6s)
./bin/start.sh my-plugin --fast  # Same, skip DB sync + verify (~6s)
./bin/start.sh stop              # Parallel stop (~2s)
./bin/start.sh status            # What is running?
./bin/start.sh logs my-plugin    # Tail plugin logs
```

### First-time & full commands

```bash
./bin/setup.sh --start           # First-time setup + start (run once)
./bin/start.sh start --all       # Start all 12 plugins (~10s warm)
./bin/start.sh dev my-plugin     # Dev mode with frontend HMR
./bin/start.sh validate          # Full health-check (49 checks)
./bin/start.sh start --all --timing  # Start with timing breakdown
./bin/start.sh help              # Show all options
```

### Core contributor commands

```bash
./bin/start.sh start --all       # Full platform
./bin/start.sh validate          # Verify all checks pass
npm test                         # Run test suite
npm run typecheck                # TypeScript check
npm run lint                     # Lint all packages
```

### Login credentials (dev environment)

| Email | Password | Role |
|-------|----------|------|
| `admin@livepeer.org` | `livepeer` | System Admin |
| `viewer@livepeer.org` | `livepeer` | Read-only Viewer |
| `gateway@livepeer.org` | `livepeer` | Gateway Manager Admin |
| `community@livepeer.org` | `livepeer` | Community Admin |
| `developer@livepeer.org` | `livepeer` | Developer API Admin |

All 12 test users share the same password: **livepeer**

---

## Summary

| | Plugin Teams | Core Contributors |
|---|---|---|
| **Own** | `plugins/<name>/` | Shell, packages, services, infra |
| **PR target** | `main` | `main` |
| **Reviewers** | Your own team (auto-assigned) | Core team (auto-assigned) |
| **Can merge** | Plugin-only PRs | Cross-cutting PRs, tag releases |
| **Deployment** | Auto-deploy to production on merge | Auto-deploy + rollback |
| **Independence** | Full autonomy within your directory | Steward the platform for all teams |
