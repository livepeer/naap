---
title: "Frontend Development"
description: "Build plugin frontends with React, SDK hooks, and the NaaP design system."
order: 2
---

## Overview

Plugin frontends are React applications that run inside the NaaP shell. They use the **Plugin SDK** to access shell services and follow the NaaP design system for consistent UI.

## Project Setup

Every plugin frontend has this structure:

```
frontend/
├── src/
│   ├── App.tsx           # Root component
│   ├── mount.tsx         # Shell mount/unmount
│   └── pages/            # Plugin pages
├── vite.config.ts        # UMD build config (createPluginConfig)
├── tsconfig.json
└── package.json
```

## Using SDK Hooks

### Authentication

```typescript
import { useAuth, useUserHasRole } from '@naap/plugin-sdk';

function MyComponent() {
  const auth = useAuth();
  const isAdmin = useUserHasRole('admin');

  if (!auth.isAuthenticated()) {
    return <div>Please log in</div>;
  }

  return (
    <div>
      <p>Welcome, {auth.getUser()?.displayName}</p>
      {isAdmin && <AdminPanel />}
    </div>
  );
}
```

### API Calls

```typescript
import { usePluginApi } from '@naap/plugin-sdk';

function DataList() {
  const api = usePluginApi();
  const [data, setData] = useState([]);

  useEffect(() => {
    api.get('/items').then(setData);
  }, []);

  return (
    <ul>
      {data.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  );
}
```

### Deployment-Aware Backend URLs

NaaP plugins run in two environments with **very different** network topologies:

| Environment | Backend access | Example URL |
|-------------|----------------|-------------|
| **Local dev** | Each plugin backend runs on its own port | `http://localhost:4006/api/v1/community/posts` |
| **Vercel / production** | All traffic goes through the Next.js API proxy on the same origin | `/api/v1/community/posts` |

The SDK provides **two functions** for URL resolution. Use the one that matches your call pattern:

#### Pattern A: API Prefix + Relative Suffix (recommended for most plugins)

Use `getPluginBackendUrl()` when your plugin calls endpoints under a single API prefix:

```typescript
import { getPluginBackendUrl } from '@naap/plugin-sdk';

const API_BASE = getPluginBackendUrl('community', {
  apiPath: '/api/v1/community',
});
// Dev:  http://localhost:4006/api/v1/community
// Prod: /api/v1/community

fetch(`${API_BASE}/posts`);       // /api/v1/community/posts
fetch(`${API_BASE}/leaderboard`); // /api/v1/community/leaderboard
```

#### Pattern B: Origin + Full Path (for cross-service calls)

Use `getServiceOrigin()` when your plugin calls **multiple different API paths** (e.g., registry, teams, installations):

```typescript
import { getServiceOrigin } from '@naap/plugin-sdk';

const origin = getServiceOrigin('base');
// Dev:  http://localhost:4000
// Prod: '' (empty string = same-origin)

fetch(`${origin}/api/v1/registry/packages`);
fetch(`${origin}/api/v1/teams/${teamId}/plugins`);
fetch(`${origin}/api/v1/installations`);
```

#### What NOT to Do

```typescript
// WRONG — breaks on Vercel (port 4006 does not exist)
const API_BASE = 'http://localhost:4006/api/v1/community';

// WRONG — appends port to production hostname
const API_BASE = `${window.location.protocol}//${window.location.hostname}:4006`;

// WRONG — creates /api/v1/base/api/v1/registry/packages (doubled path!)
const base = getPluginBackendUrl('base');  // returns '/api/v1/base' in prod
fetch(`${base}/api/v1/registry/packages`); // DOUBLED!
```

#### Quick Reference

| I want to... | Use this function |
|---|---|
| Call `/api/v1/community/posts`, `/api/v1/community/tags` | `getPluginBackendUrl('community', { apiPath: '/api/v1/community' })` then append `/posts`, `/tags` |
| Call `/api/v1/registry/packages`, `/api/v1/teams/...` | `getServiceOrigin('base')` then append the full path |
| Build a React hook with automatic URL resolution | `usePluginApi({ pluginName: 'my-plugin', apiPath: '/api/v1/my-plugin' })` |

Run `./bin/validate-plugin-urls.sh` before committing to catch common URL mistakes.

#### Pre-Built API Clients

The SDK also exports two higher-level clients that use `getServiceOrigin('base')` internally.
You do **not** need to call `getServiceOrigin()` yourself when using these:

```typescript
import { createShellApiClient, createIntegrationClient } from '@naap/plugin-sdk';

// For core shell endpoints (auth, teams, installations, etc.)
const shell = createShellApiClient();
await shell.get('/api/v1/registry/packages');

// For plugin-to-plugin integration calls
const integration = createIntegrationClient();
await integration.get('/api/v1/community/posts');
```

#### How Production Detection Works

The SDK uses `isProductionHost()` for unified environment detection:

- **In the browser:** checks `window.location.hostname` against known production hosts
- **On the server (SSR):** checks environment variables (`VERCEL`, `NEXT_PUBLIC_VERCEL_URL`, etc.)

You should never implement your own environment detection — always rely on the SDK functions.

#### Catch-All Proxy & API Route Parity

On **Vercel / production**, the Next.js catch-all proxy (`/api/v1/[plugin]/[...path]`) returns
**501 Not Implemented** for any route that does not have a dedicated Next.js route handler.
This means every plugin API endpoint must have a corresponding file at:

```
apps/web-next/src/app/api/v1/{plugin-name}/...
```

There are currently **46+ dedicated route handlers** covering all plugin endpoints.
If you add a new API endpoint to your plugin backend, you must also add a matching
Next.js route handler — otherwise the endpoint will not work in production.

### Event Communication

```typescript
import { useEvents } from '@naap/plugin-sdk';

function StatusWidget() {
  const events = useEvents();
  const [status, setStatus] = useState('idle');

  useEffect(() => {
    // Listen for events from other plugins
    const unsub = events.on('gateway:status-changed', (data) => {
      setStatus(data.status);
    });
    return unsub;
  }, [events]);

  // Emit events for other plugins
  const handleAction = () => {
    events.emit('task-tracker:task-completed', { taskId: '123' });
  };

  return <button onClick={handleAction}>Complete ({status})</button>;
}
```

### Notifications

```typescript
import { useNotify } from '@naap/plugin-sdk';

function SaveButton() {
  const notify = useNotify();

  const handleSave = async () => {
    try {
      await saveData();
      notify.success('Saved successfully!');
    } catch (error) {
      notify.error('Failed to save. Please try again.');
    }
  };

  return <button onClick={handleSave}>Save</button>;
}
```

### Theme-Aware Components

```typescript
import { useThemeService } from '@naap/plugin-sdk';

function ThemedCard({ children }) {
  const theme = useThemeService();

  return (
    <div className={`rounded-xl border p-4 ${
      theme.mode === 'dark'
        ? 'bg-gray-800 border-gray-700'
        : 'bg-white border-gray-200'
    }`}>
      {children}
    </div>
  );
}
```

## Styling

### Tailwind CSS

Plugins should use Tailwind CSS classes for styling. The shell provides CSS variables for all theme colors:

```css
/* Available CSS variables */
--background
--foreground
--primary
--primary-foreground
--muted
--muted-foreground
--border
--card
--card-foreground
```

### Using the Theme

```typescript
// Use semantic color classes
<div className="bg-background text-foreground">
  <h1 className="text-primary">Title</h1>
  <p className="text-muted-foreground">Description</p>
  <div className="bg-card border border-border rounded-xl">
    Card content
  </div>
</div>
```

## Routing Within a Plugin

Plugins can have multiple pages using their route prefix:

```typescript
// plugin.json routes: ["/task-tracker", "/task-tracker/*"]

function App() {
  const path = window.location.pathname;

  if (path === '/task-tracker/settings') {
    return <SettingsPage />;
  }

  return <TaskListPage />;
}
```

## Shared UI Components

Use components from `@naap/ui` for consistent design:

```typescript
import { Card, Badge, DataTable, SearchInput } from '@naap/ui';

function PluginPage() {
  return (
    <Card>
      <SearchInput placeholder="Search tasks..." />
      <DataTable columns={columns} data={data} />
      <Badge variant="success">Active</Badge>
    </Card>
  );
}
```

## Build Configuration

### Shared Vite Config

All plugins use the shared build configuration from `@naap/plugin-build`. Your `vite.config.ts` should look like this:

```typescript
import { createPluginConfig } from '@naap/plugin-build/vite';

export default createPluginConfig({
  name: 'my-plugin',
  displayName: 'My Plugin',
  globalName: 'NaapPluginMyPlugin',
  defaultCategory: 'platform',
});
```

This shared config handles:
- UMD bundle output, React externals, rollup globals
- **PostCSS / Tailwind CSS** — configured inline; do **not** add a `postcss.config.js` to your plugin
- Manifest generation and bundle validation

### Do NOT Add postcss.config.js

PostCSS (Tailwind CSS, Autoprefixer) is configured centrally in the shared Vite config. Adding a `postcss.config.js` in your plugin will **break Vercel builds** because PostCSS tries to `require('tailwindcss')` from your plugin directory, where it cannot find the hoisted dependency.

```
plugins/my-plugin/frontend/
├── tailwind.config.js      ← YES — keep this (per-plugin theme/content)
├── postcss.config.js       ← NO — do NOT create this file
└── vite.config.ts          ← Uses createPluginConfig (includes PostCSS)
```

### Tailwind Config

Each plugin keeps its own `tailwind.config.js` for content paths and theme extensions. The shared Vite config passes `{ config: './tailwind.config.js' }` to Tailwind, so your config is automatically picked up.

## Hot Reload

During development, `naap-plugin dev` enables hot module replacement. Changes to your React components update instantly in the browser without losing state.
